
[Haskell Programming from First Principles](http://haskellbook.com/progress.html)

 - [x] Front matter
 - [x] Lambda Calculus
     - [x] All You Need is Lambda
     - [x] What is functional programming?
     - [x] What is a function?
     - [x] The structure of lambda terms
     - [x] Beta reduction
     - [x] Multiple arguments
     - [x] Evaluation is simplification
     - [x] Combinators
     - [x] Divergence
     - [x] Summary
     - [x] Chapter Exercises
     - [x] Answers
     - [x] Definitions
     - [x] Follow-up resources
 - [x] Hello Haskell
     - [x] Hello, Haskel
     - [x] Interacting with Haskell code
     - [x] Understanding expressions
     - [x] Functions
     - [x] Infix operators
     - [x] Declaring values
     - [x] Arithmetic functions in Haskell
     - [x] Negative numbers
     - [x] Parenthesizing infix functions
     - [x] Laws for quotients and remainders
     - [x] Evaluation
     - [x] Let and where
     - [x] Chapter Exercises
     - [x] Definitions
     - [x] Follow-up resources
 - [x] Strings
     - [x] Printing strings
     - [x] A first look at types
     - [x] Printing simple strings
     - [x] Types of concatenation functions
     - [x] Concatenation and scoping
     - [x] More list functions
     - [x] Chapter Exercises
     - [x] Definitions
 - [x] Basic Datatypes
     - [x] Basic Datatypes
     - [x] Anatomy of a data declaration
     - [x] Numeric types
     - [x] Comparing values
     - [x] Tuples
     - [x] Lists
     - [x] Chapter Exercises
     - [x] Definitions
 - [ ] Types
     - [x] Types
     - [x] What are types?
     - [x] Querying and Reading Types
     - [x] Typeclass constrained type variables
     - [x] Currying
     - [ ] Polymorphism (left off on page 165)
     - [ ] Type inference
     - [ ] Asserting types for declarations
     - [ ] Chapter Exercises
     - [ ] Definitions
     - [ ] Follow-up resources
 - [ ] Typeclasses
     - [ ] Typeclasses
     - [ ] What are typeclasses?
     - [ ] Back to Bool
     - [ ] Eq
     - [ ] num
     - [ ] Type-defaulting typeclasses
     - [ ] Ord
     - [ ] Enum
     - [ ] Show
     - [ ] Read
     - [ ] Instances are dispatched by type
     - [ ] Writing typeclass instances
     - [ ] Gimme more operations
     - [ ] Chapter Exercises
     - [ ] Chapter Definitions
     - [ ] Typeclass inheritance, partial
     - [ ] Follow-up resources
 - [ ] Functions
     - [ ] Make it func-y
     - [ ] Arguments and parameters
     - [ ] Anonymous functions
     - [ ] Pattern matching
     - [ ] Case expressions
     - [ ] Higher-order functions
     - [ ] Guards
     - [ ] Function composition
     - [ ] Pointfree style
     - [ ] Demonstrating composition
     - [ ] Chapter Exercises
     - [ ] Chapter Definitions
     - [ ] Follow-up Resources
 - [ ] Recursion
 - [ ] Lists
 - [ ] Folds
 - [ ] Algebraic datatypes
 - [ ] Signaling Adversity
 - [ ] Building projects in Haskell
 - [ ] Testing
 - [ ] Monoid, Semigroup
 - [ ] Functors
 - [ ] Applicative
 - [ ] Monad (SPOOKY? No.)
 - [ ] Abstract structure applied
 - [ ] Foldable
 - [ ] Traversable
 - [ ] Reader
 - [ ] State
 - [ ] Parsers
 - [ ] Composing Types
 - [ ] Monad Transformers
 - [ ] Non-strictness
 - [ ] Commonly used data structures
 - [ ] Demystifying IO
 - [ ] Exceptions
 - [ ] Final Project
